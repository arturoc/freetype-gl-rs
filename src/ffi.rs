/* automatically generated by rust-bindgen */
#![allow(dead_code)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]


pub const _FEATURES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _DEFAULT_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC11 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC99 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC95 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX_IMPLICITLY : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_C_SOURCE : :: std :: os :: raw :: c_uint = 200809 ; pub const __USE_POSIX : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX2 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199309 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199506 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K8 : :: std :: os :: raw :: c_uint = 1 ; pub const _ATFILE_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_MISC : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ATFILE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_FORTIFY_LEVEL : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : :: std :: os :: raw :: c_uint = 0 ; pub const _STDC_PREDEF_H : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559_COMPLEX__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_ISO_10646__ : :: std :: os :: raw :: c_uint = 201706 ; pub const __STDC_NO_THREADS__ : :: std :: os :: raw :: c_uint = 1 ; pub const __GNU_LIBRARY__ : :: std :: os :: raw :: c_uint = 6 ; pub const __GLIBC__ : :: std :: os :: raw :: c_uint = 2 ; pub const __GLIBC_MINOR__ : :: std :: os :: raw :: c_uint = 26 ; pub const _SYS_CDEFS_H : :: std :: os :: raw :: c_uint = 1 ; pub const __glibc_c99_flexarr_available : :: std :: os :: raw :: c_uint = 1 ; pub const __WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : :: std :: os :: raw :: c_uint = 1 ; pub const __SYSCALL_WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __HAVE_GENERIC_SELECTION : :: std :: os :: raw :: c_uint = 1 ; pub const __GLIBC_USE_LIB_EXT2 : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const _STDLIB_H : :: std :: os :: raw :: c_uint = 1 ; pub const WNOHANG : :: std :: os :: raw :: c_uint = 1 ; pub const WUNTRACED : :: std :: os :: raw :: c_uint = 2 ; pub const WSTOPPED : :: std :: os :: raw :: c_uint = 2 ; pub const WEXITED : :: std :: os :: raw :: c_uint = 4 ; pub const WCONTINUED : :: std :: os :: raw :: c_uint = 8 ; pub const WNOWAIT : :: std :: os :: raw :: c_uint = 16777216 ; pub const __WNOTHREAD : :: std :: os :: raw :: c_uint = 536870912 ; pub const __WALL : :: std :: os :: raw :: c_uint = 1073741824 ; pub const __WCLONE : :: std :: os :: raw :: c_uint = 2147483648 ; pub const __ENUM_IDTYPE_T : :: std :: os :: raw :: c_uint = 1 ; pub const __W_CONTINUED : :: std :: os :: raw :: c_uint = 65535 ; pub const __WCOREFLAG : :: std :: os :: raw :: c_uint = 128 ; pub const __HAVE_FLOAT128 : :: std :: os :: raw :: c_uint = 0 ; pub const __HAVE_DISTINCT_FLOAT128 : :: std :: os :: raw :: c_uint = 0 ; pub const __ldiv_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __lldiv_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const RAND_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const EXIT_FAILURE : :: std :: os :: raw :: c_uint = 1 ; pub const EXIT_SUCCESS : :: std :: os :: raw :: c_uint = 0 ; pub const _SYS_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPESIZES_H : :: std :: os :: raw :: c_uint = 1 ; pub const __OFF_T_MATCHES_OFF64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __INO_T_MATCHES_INO64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __FD_SETSIZE : :: std :: os :: raw :: c_uint = 1024 ; pub const __clock_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __clockid_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __time_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __timer_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_STDINT_INTN_H : :: std :: os :: raw :: c_uint = 1 ; pub const __BIT_TYPES_DEFINED__ : :: std :: os :: raw :: c_uint = 1 ; pub const _ENDIAN_H : :: std :: os :: raw :: c_uint = 1 ; pub const __LITTLE_ENDIAN : :: std :: os :: raw :: c_uint = 1234 ; pub const __BIG_ENDIAN : :: std :: os :: raw :: c_uint = 4321 ; pub const __PDP_ENDIAN : :: std :: os :: raw :: c_uint = 3412 ; pub const __BYTE_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const __FLOAT_WORD_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const LITTLE_ENDIAN : :: std :: os :: raw :: c_uint = 1234 ; pub const BIG_ENDIAN : :: std :: os :: raw :: c_uint = 4321 ; pub const PDP_ENDIAN : :: std :: os :: raw :: c_uint = 3412 ; pub const BYTE_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const _BITS_BYTESWAP_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_UINTN_IDENTITY_H : :: std :: os :: raw :: c_uint = 1 ; pub const _SYS_SELECT_H : :: std :: os :: raw :: c_uint = 1 ; pub const __FD_ZERO_STOS : & 'static [ u8 ; 6usize ] = b"stosq\0" ; pub const __sigset_t_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __timeval_defined : :: std :: os :: raw :: c_uint = 1 ; pub const __timespec_defined : :: std :: os :: raw :: c_uint = 1 ; pub const FD_SETSIZE : :: std :: os :: raw :: c_uint = 1024 ; pub const _SYS_SYSMACROS_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_SYSMACROS_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_PTHREADTYPES_COMMON_H : :: std :: os :: raw :: c_uint = 1 ; pub const _THREAD_SHARED_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_PTHREADTYPES_ARCH_H : :: std :: os :: raw :: c_uint = 1 ; pub const __SIZEOF_PTHREAD_MUTEX_T : :: std :: os :: raw :: c_uint = 40 ; pub const __SIZEOF_PTHREAD_ATTR_T : :: std :: os :: raw :: c_uint = 56 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : :: std :: os :: raw :: c_uint = 56 ; pub const __SIZEOF_PTHREAD_BARRIER_T : :: std :: os :: raw :: c_uint = 32 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : :: std :: os :: raw :: c_uint = 4 ; pub const __SIZEOF_PTHREAD_COND_T : :: std :: os :: raw :: c_uint = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : :: std :: os :: raw :: c_uint = 4 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : :: std :: os :: raw :: c_uint = 8 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : :: std :: os :: raw :: c_uint = 4 ; pub const __PTHREAD_MUTEX_LOCK_ELISION : :: std :: os :: raw :: c_uint = 1 ; pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED : :: std :: os :: raw :: c_uint = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : :: std :: os :: raw :: c_uint = 1 ; pub const __have_pthread_attr_t : :: std :: os :: raw :: c_uint = 1 ; pub const _ALLOCA_H : :: std :: os :: raw :: c_uint = 1 ; pub const _STDINT_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_WCHAR_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_STDINT_UINTN_H : :: std :: os :: raw :: c_uint = 1 ; pub const INT8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const UINT8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_LEAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_LEAST16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT_LEAST32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const UINT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_FAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_FAST16_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST32_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_FAST16_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const INT_FAST32_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINT_FAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_FAST16_MAX : :: std :: os :: raw :: c_int = -1 ; pub const UINT_FAST32_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INTPTR_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INTPTR_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINTPTR_MAX : :: std :: os :: raw :: c_int = -1 ; pub const PTRDIFF_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const PTRDIFF_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const SIG_ATOMIC_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const SIZE_MAX : :: std :: os :: raw :: c_int = -1 ; pub const WINT_MIN : :: std :: os :: raw :: c_uint = 0 ; pub const WINT_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub type wchar_t = :: std :: os :: raw :: c_int ; pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } extern "C" {
 pub fn __ctype_get_mb_cur_max ( ) -> usize ;
} extern "C" {
 pub fn atof ( __nptr : * const :: std :: os :: raw :: c_char , ) -> f64 ;
} extern "C" {
 pub fn atoi ( __nptr : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn atol ( __nptr : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn atoll ( __nptr : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
 pub fn strtod ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , ) -> f64 ;
} extern "C" {
 pub fn strtof ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , ) -> f32 ;
} extern "C" {
 pub fn strtold ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , ) -> f64 ;
} extern "C" {
 pub fn strtol ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn strtoul ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_ulong ;
} extern "C" {
 pub fn strtoq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
 pub fn strtouq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_ulonglong ;
} extern "C" {
 pub fn strtoll ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
 pub fn strtoull ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_ulonglong ;
} extern "C" {
 pub fn l64a ( __n : :: std :: os :: raw :: c_long , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn a64l ( __s : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_long ;
} pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type off_t = __off_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type clockid_t = __clockid_t ; pub type time_t = __time_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( fd_set ) , "::" , stringify ! ( __fds_bits ) ) ) ; } pub type fd_mask = __fd_mask ; extern "C" {
 pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn gnu_dev_major ( __dev : __dev_t , ) -> :: std :: os :: raw :: c_uint ;
} extern "C" {
 pub fn gnu_dev_minor ( __dev : __dev_t , ) -> :: std :: os :: raw :: c_uint ;
} extern "C" {
 pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint , ) -> __dev_t ;
} pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar ; 7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_rwlock_arch_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_rwlock_arch_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( __pthread_rwlock_arch_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_rwlock_arch_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_rwlock_arch_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __readers as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __readers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __writers as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __wrphase_futex as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __wrphase_futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __writers_futex as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers_futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad3 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad4 as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __cur_writer as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __cur_writer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __rwelision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __flags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_internal_list ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_mutex_s ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g_size : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [ :: std :: os :: raw :: c_uint ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : :: std :: os :: raw :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) . __wseq as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) . __wseq32 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq32 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : :: std :: os :: raw :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) . __g1_start as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) . __g1_start32 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start32 ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g_refs as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g_size as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g1_orig_size as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g1_orig_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __wrefs as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __wrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_cond_s ) ) . __g_signals as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_signals ) ) ) ; } pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_condattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_condattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long ,  } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long ,  } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong ,  } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long ,  } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long ,  } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrier_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) ) ; } extern "C" {
 pub fn random ( ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn srandom ( __seed : :: std :: os :: raw :: c_uint , ) ;
} extern "C" {
 pub fn initstate ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn setstate ( __statebuf : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [ test ] fn bindgen_test_layout_random_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < random_data > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( random_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < random_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( random_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . fptr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( fptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . rptr as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . state as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . rand_type as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . rand_deg as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_deg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . rand_sep as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_sep ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( random_data ) , "::" , stringify ! ( end_ptr ) ) ) ; } extern "C" {
 pub fn random_r ( __buf : * mut random_data , __result : * mut i32 , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn srandom_r ( __seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn initstate_r ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn setstate_r ( __statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn rand ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn srand ( __seed : :: std :: os :: raw :: c_uint , ) ;
} extern "C" {
 pub fn rand_r ( __seed : * mut :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn drand48 ( ) -> f64 ;
} extern "C" {
 pub fn erand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort , ) -> f64 ;
} extern "C" {
 pub fn lrand48 ( ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn nrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn mrand48 ( ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn jrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn srand48 ( __seedval : :: std :: os :: raw :: c_long , ) ;
} extern "C" {
 pub fn seed48 ( __seed16v : * mut :: std :: os :: raw :: c_ushort , ) -> * mut :: std :: os :: raw :: c_ushort ;
} extern "C" {
 pub fn lcong48 ( __param : * mut :: std :: os :: raw :: c_ushort , ) ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct drand48_data { pub __x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __old_x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_drand48_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < drand48_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( drand48_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < drand48_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( drand48_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _ as usize } , 6usize , concat ! ( "Alignment of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __old_x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __c ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __init ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __a ) ) ) ; } extern "C" {
 pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn erand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn nrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn jrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn srand48_r ( __seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn seed48_r ( __seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn lcong48_r ( __param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn malloc ( __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn calloc ( __nmemb : usize , __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn realloc ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn free ( __ptr : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
 pub fn alloca ( __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn valloc ( __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn posix_memalign ( __memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn aligned_alloc ( __alignment : usize , __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn abort ( ) ;
} extern "C" {
 pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void ) > , __arg : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn exit ( __status : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
 pub fn quick_exit ( __status : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
 pub fn _Exit ( __status : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
 pub fn getenv ( __name : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn putenv ( __string : * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn setenv ( __name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn unsetenv ( __name : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn clearenv ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mktemp ( __template : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn mkstemp ( __template : * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mkstemps ( __template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mkdtemp ( __template : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn system ( __command : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn realpath ( __name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" {
 pub fn bsearch ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
 pub fn qsort ( __base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t , ) ;
} extern "C" {
 pub fn abs ( __x : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn labs ( __x : :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
 pub fn llabs ( __x : :: std :: os :: raw :: c_longlong , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
 pub fn div ( __numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int , ) -> div_t ;
} extern "C" {
 pub fn ldiv ( __numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long , ) -> ldiv_t ;
} extern "C" {
 pub fn lldiv ( __numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong , ) -> lldiv_t ;
} extern "C" {
 pub fn ecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn fcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn gcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn qecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn qfcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn qgcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
 pub fn ecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn fcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn qecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn qfcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mblen ( __s : * const :: std :: os :: raw :: c_char , __n : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn wctomb ( __s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize , ) -> usize ;
} extern "C" {
 pub fn wcstombs ( __s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize , ) -> usize ;
} extern "C" {
 pub fn rpmatch ( __response : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn getsubopt ( __optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * const :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
 pub fn getloadavg ( __loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const max_align_t ) ) . __clang_max_align_nonce1 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const max_align_t ) ) . __clang_max_align_nonce2 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce2 ) ) ) ; }
 /// Generic vector structure.
///
/// @memberof vector
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vector_t {
 /// Pointer to dynamically allocated items.
 pub items : * mut :: std :: os :: raw :: c_void ,
 /// Number of items that can be held in currently allocated storage.
 pub capacity : usize ,
 /// Number of items.
 pub size : usize ,
 /// Size (in bytes) of a single item.
 pub item_size : usize , } # [ test ] fn bindgen_test_layout_vector_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vector_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( vector_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vector_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( vector_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vector_t ) ) . items as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vector_t ) , "::" , stringify ! ( items ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vector_t ) ) . capacity as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vector_t ) , "::" , stringify ! ( capacity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vector_t ) ) . size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( vector_t ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vector_t ) ) . item_size as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( vector_t ) , "::" , stringify ! ( item_size ) ) ) ; } extern "C" {

 /// Creates a new empty vector.
///
/// @param   item_size    item size in bytes
/// @return               a new empty vector
///

 pub fn vector_new ( item_size : usize , ) -> * mut vector_t ;
} extern "C" {

 /// Deletes a vector.
///
/// @param self a vector structure
///

 pub fn vector_delete ( self_ : * mut vector_t , ) ;
} extern "C" {

 /// Returns a pointer to the item located at specified index.
///
/// @param  self  a vector structure
/// @param  index the index of the item to be returned
/// @return       pointer on the specified item

 pub fn vector_get ( self_ : * const vector_t , index : usize , ) -> * const :: std :: os :: raw :: c_void ;
} extern "C" {

 /// Returns a pointer to the first item.
///
/// @param  self  a vector structure
/// @return       pointer on the first item

 pub fn vector_front ( self_ : * const vector_t , ) -> * const :: std :: os :: raw :: c_void ;
} extern "C" {

 /// Returns a pointer to the last item
///
/// @param  self  a vector structure
/// @return pointer on the last item

 pub fn vector_back ( self_ : * const vector_t , ) -> * const :: std :: os :: raw :: c_void ;
} extern "C" {

 /// Check if an item is contained within the vector.
///
/// @param  self  a vector structure
/// @param  item  item to be searched in the vector
/// @param  cmp   a pointer a comparison function
/// @return       1 if item is contained within the vector, 0 otherwise

 pub fn vector_contains ( self_ : * const vector_t , item : * const :: std :: os :: raw :: c_void , cmp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {

 /// Checks whether the vector is empty.
///
/// @param  self  a vector structure
/// @return       1 if the vector is empty, 0 otherwise

 pub fn vector_empty ( self_ : * const vector_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {

 /// Returns the number of items
///
/// @param  self  a vector structure
/// @return       number of items

 pub fn vector_size ( self_ : * const vector_t , ) -> usize ;
} extern "C" {

 /// Reserve storage such that it can hold at last size items.
///
/// @param  self  a vector structure
/// @param  size  the new storage capacity

 pub fn vector_reserve ( self_ : * mut vector_t , size : usize , ) ;
} extern "C" {

 /// Returns current storage capacity
///
/// @param  self  a vector structure
/// @return       storage capacity

 pub fn vector_capacity ( self_ : * const vector_t , ) -> usize ;
} extern "C" {

 /// Decrease capacity to fit actual size.
///
/// @param  self  a vector structure

 pub fn vector_shrink ( self_ : * mut vector_t , ) ;
} extern "C" {

 /// Removes all items.
///
/// @param  self  a vector structure

 pub fn vector_clear ( self_ : * mut vector_t , ) ;
} extern "C" {

 /// Replace an item.
///
/// @param  self  a vector structure
/// @param  index the index of the item to be replaced
/// @param  item  the new item

 pub fn vector_set ( self_ : * mut vector_t , index : usize , item : * const :: std :: os :: raw :: c_void , ) ;
} extern "C" {

 /// Erase an item.
///
/// @param  self  a vector structure
/// @param  index the index of the item to be erased

 pub fn vector_erase ( self_ : * mut vector_t , index : usize , ) ;
} extern "C" {

 /// Erase a range of items.
///
/// @param  self  a vector structure
/// @param  first the index of the first item to be erased
/// @param  last  the index of the last item to be erased

 pub fn vector_erase_range ( self_ : * mut vector_t , first : usize , last : usize , ) ;
} extern "C" {

 /// Appends given item to the end of the vector.
///
/// @param  self a vector structure
/// @param  item the item to be inserted

 pub fn vector_push_back ( self_ : * mut vector_t , item : * const :: std :: os :: raw :: c_void , ) ;
} extern "C" {

 /// Removes the last item of the vector.
///
/// @param  self a vector structure

 pub fn vector_pop_back ( self_ : * mut vector_t , ) ;
} extern "C" {

 /// Resizes the vector to contain size items
///
/// If the current size is less than size, additional items are appended and
/// initialized with value. If the current size is greater than size, the
/// vector is reduced to its first size elements.
///
/// @param  self a vector structure
/// @param  size the new size

 pub fn vector_resize ( self_ : * mut vector_t , size : usize , ) ;
} extern "C" {

 /// Insert a single item at specified index.
///
/// @param  self  a vector structure
/// @param  index location before which to insert item
/// @param  item  the item to be inserted

 pub fn vector_insert ( self_ : * mut vector_t , index : usize , item : * const :: std :: os :: raw :: c_void , ) ;
} extern "C" {

 /// Insert raw data at specified index.
///
/// @param  self  a vector structure
/// @param  index location before which to insert item
/// @param  data  a pointer to the items to be inserted
/// @param  count the number of items to be inserted

 pub fn vector_insert_data ( self_ : * mut vector_t , index : usize , data : * const :: std :: os :: raw :: c_void , count : usize , ) ;
} extern "C" {

 /// Append raw data to the end of the vector.
///
/// @param  self  a vector structure
/// @param  data  a pointer to the items to be inserted
/// @param  count the number of items to be inserted

 pub fn vector_push_back_data ( self_ : * mut vector_t , data : * const :: std :: os :: raw :: c_void , count : usize , ) ;
} extern "C" {

 /// Sort vector items according to cmp function.
///
/// @param  self  a vector structure
/// @param  cmp   a pointer a comparison function

 pub fn vector_sort ( self_ : * mut vector_t , cmp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) ;
}
 /// Tuple of 4 ints.
///
/// Each field can be addressed using several aliases:
/// - First component:  <b>x</b>, <b>r</b>, <b>red</b> or <b>vstart</b>
/// - Second component: <b>y</b>, <b>g</b>, <b>green</b> or <b>vcount</b>
/// - Third component:  <b>z</b>, <b>b</b>, <b>blue</b>, <b>width</b> or <b>istart</b>
/// - Fourth component: <b>w</b>, <b>a</b>, <b>alpha</b>, <b>height</b> or <b>icount</b>
///
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ivec4 {
 /// < All compoments at once
 pub data : [ :: std :: os :: raw :: c_int ; 4usize ] , pub __bindgen_anon_1 : ivec4__bindgen_ty_1 , pub __bindgen_anon_2 : ivec4__bindgen_ty_2 , pub __bindgen_anon_3 : ivec4__bindgen_ty_3 , pub __bindgen_anon_4 : ivec4__bindgen_ty_4 , pub __bindgen_anon_5 : ivec4__bindgen_ty_5 ,  } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec4__bindgen_ty_1 {
 /// < Alias for first component
 pub x : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub y : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub z : :: std :: os :: raw :: c_int ,
 /// < Alias for fourht component
 pub w : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec4__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec4__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ivec4__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec4__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec4__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_1 ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_1 ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_1 ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_1 ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_1 ) ) . z as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_1 ) , "::" , stringify ! ( z ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_1 ) ) . w as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_1 ) , "::" , stringify ! ( w ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec4__bindgen_ty_2 {
 /// < Alias for first component
 pub x_ : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub y_ : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub width : :: std :: os :: raw :: c_int ,
 /// < Alias for fourth component
 pub height : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec4__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec4__bindgen_ty_2 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ivec4__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec4__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec4__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_2 ) ) . x_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_2 ) , "::" , stringify ! ( x_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_2 ) ) . y_ as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_2 ) , "::" , stringify ! ( y_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_2 ) ) . width as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_2 ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_2 ) ) . height as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_2 ) , "::" , stringify ! ( height ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec4__bindgen_ty_3 {
 /// < Alias for first component
 pub r : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub g : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub b : :: std :: os :: raw :: c_int ,
 /// < Alias for fourth component
 pub a : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec4__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec4__bindgen_ty_3 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ivec4__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec4__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec4__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_3 ) ) . r as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_3 ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_3 ) ) . g as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_3 ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_3 ) ) . b as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_3 ) , "::" , stringify ! ( b ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_3 ) ) . a as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_3 ) , "::" , stringify ! ( a ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec4__bindgen_ty_4 {
 /// < Alias for first component
 pub red : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub green : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub blue : :: std :: os :: raw :: c_int ,
 /// < Alias for fourth component
 pub alpha : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec4__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec4__bindgen_ty_4 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ivec4__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec4__bindgen_ty_4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec4__bindgen_ty_4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_4 ) ) . red as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_4 ) , "::" , stringify ! ( red ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_4 ) ) . green as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_4 ) , "::" , stringify ! ( green ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_4 ) ) . blue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_4 ) , "::" , stringify ! ( blue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_4 ) ) . alpha as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_4 ) , "::" , stringify ! ( alpha ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec4__bindgen_ty_5 {
 /// < Alias for first component
 pub vstart : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub vcount : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub istart : :: std :: os :: raw :: c_int ,
 /// < Alias for fourth component
 pub icount : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec4__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec4__bindgen_ty_5 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ivec4__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec4__bindgen_ty_5 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec4__bindgen_ty_5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_5 ) ) . vstart as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_5 ) , "::" , stringify ! ( vstart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_5 ) ) . vcount as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_5 ) , "::" , stringify ! ( vcount ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_5 ) ) . istart as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_5 ) , "::" , stringify ! ( istart ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4__bindgen_ty_5 ) ) . icount as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4__bindgen_ty_5 ) , "::" , stringify ! ( icount ) ) ) ; } # [ test ] fn bindgen_test_layout_ivec4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec4 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ivec4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec4 ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec4 ) , "::" , stringify ! ( data ) ) ) ; }
 /// Tuple of 3 ints.
///
/// Each field can be addressed using several aliases:
/// - First component:  <b>x</b>, <b>r</b> or <b>red</b>
/// - Second component: <b>y</b>, <b>g</b> or <b>green</b>
/// - Third component:  <b>z</b>, <b>b</b> or <b>blue</b>
///
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ivec3 {
 /// < All compoments at once
 pub data : [ :: std :: os :: raw :: c_int ; 3usize ] , pub __bindgen_anon_1 : ivec3__bindgen_ty_1 , pub __bindgen_anon_2 : ivec3__bindgen_ty_2 , pub __bindgen_anon_3 : ivec3__bindgen_ty_3 ,  } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec3__bindgen_ty_1 {
 /// < Alias for first component
 pub x : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub y : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub z : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec3__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec3__bindgen_ty_1 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ivec3__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec3__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec3__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_1 ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_1 ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_1 ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_1 ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_1 ) ) . z as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_1 ) , "::" , stringify ! ( z ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec3__bindgen_ty_2 {
 /// < Alias for first component
 pub r : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub g : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub b : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec3__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec3__bindgen_ty_2 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ivec3__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec3__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec3__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_2 ) ) . r as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_2 ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_2 ) ) . g as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_2 ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_2 ) ) . b as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_2 ) , "::" , stringify ! ( b ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec3__bindgen_ty_3 {
 /// < Alias for first component
 pub red : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub green : :: std :: os :: raw :: c_int ,
 /// < Alias for third component
 pub blue : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec3__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec3__bindgen_ty_3 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ivec3__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec3__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec3__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_3 ) ) . red as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_3 ) , "::" , stringify ! ( red ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_3 ) ) . green as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_3 ) , "::" , stringify ! ( green ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3__bindgen_ty_3 ) ) . blue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3__bindgen_ty_3 ) , "::" , stringify ! ( blue ) ) ) ; } # [ test ] fn bindgen_test_layout_ivec3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec3 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ivec3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec3 ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec3 ) , "::" , stringify ! ( data ) ) ) ; }
 /// Tuple of 2 ints.
///
/// Each field can be addressed using several aliases:
/// - First component: <b>x</b>, <b>s</b> or <b>start</b>
/// - Second component: <b>y</b>, <b>t</b> or <b>end</b>
///
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ivec2 {
 /// < All compoments at once
 pub data : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __bindgen_anon_1 : ivec2__bindgen_ty_1 , pub __bindgen_anon_2 : ivec2__bindgen_ty_2 , pub __bindgen_anon_3 : ivec2__bindgen_ty_3 ,  } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec2__bindgen_ty_1 {
 /// < Alias for first component
 pub x : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub y : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ivec2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2__bindgen_ty_1 ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2__bindgen_ty_1 ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2__bindgen_ty_1 ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2__bindgen_ty_1 ) , "::" , stringify ! ( y ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec2__bindgen_ty_2 {
 /// < Alias for first component
 pub s : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub t : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec2__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec2__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ivec2__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec2__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec2__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2__bindgen_ty_2 ) ) . s as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2__bindgen_ty_2 ) , "::" , stringify ! ( s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2__bindgen_ty_2 ) ) . t as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2__bindgen_ty_2 ) , "::" , stringify ! ( t ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ivec2__bindgen_ty_3 {
 /// < Alias for first component
 pub start : :: std :: os :: raw :: c_int ,
 /// < Alias for second component
 pub end : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ivec2__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec2__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ivec2__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec2__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec2__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2__bindgen_ty_3 ) ) . start as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2__bindgen_ty_3 ) , "::" , stringify ! ( start ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2__bindgen_ty_3 ) ) . end as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2__bindgen_ty_3 ) , "::" , stringify ! ( end ) ) ) ; } # [ test ] fn bindgen_test_layout_ivec2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ivec2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ivec2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ivec2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ivec2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ivec2 ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ivec2 ) , "::" , stringify ! ( data ) ) ) ; }
 /// Tuple of 4 floats.
///
/// Each field can be addressed using several aliases:
/// - First component:  <b>x</b>, <b>left</b>, <b>r</b> or <b>red</b>
/// - Second component: <b>y</b>, <b>top</b>, <b>g</b> or <b>green</b>
/// - Third component:  <b>z</b>, <b>width</b>, <b>b</b> or <b>blue</b>
/// - Fourth component: <b>w</b>, <b>height</b>, <b>a</b> or <b>alpha</b>
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union vec4 {
 /// < All compoments at once
 pub data : [ f32 ; 4usize ] , pub __bindgen_anon_1 : vec4__bindgen_ty_1 , pub __bindgen_anon_2 : vec4__bindgen_ty_2 , pub __bindgen_anon_3 : vec4__bindgen_ty_3 , pub __bindgen_anon_4 : vec4__bindgen_ty_4 ,  } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec4__bindgen_ty_1 {
 /// < Alias for first component
 pub x : f32 ,
 /// < Alias for second component
 pub y : f32 ,
 /// < Alias for third component
 pub z : f32 ,
 /// < Alias for fourth component
 pub w : f32 , } # [ test ] fn bindgen_test_layout_vec4__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec4__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( vec4__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec4__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec4__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_1 ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_1 ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_1 ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_1 ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_1 ) ) . z as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_1 ) , "::" , stringify ! ( z ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_1 ) ) . w as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_1 ) , "::" , stringify ! ( w ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec4__bindgen_ty_2 {
 /// < Alias for first component
 pub left : f32 ,
 /// < Alias for second component
 pub top : f32 ,
 /// < Alias for third component
 pub width : f32 ,
 /// < Alias for fourth component
 pub height : f32 , } # [ test ] fn bindgen_test_layout_vec4__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec4__bindgen_ty_2 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( vec4__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec4__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec4__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_2 ) ) . left as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_2 ) , "::" , stringify ! ( left ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_2 ) ) . top as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_2 ) , "::" , stringify ! ( top ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_2 ) ) . width as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_2 ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_2 ) ) . height as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_2 ) , "::" , stringify ! ( height ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec4__bindgen_ty_3 {
 /// < Alias for first component
 pub r : f32 ,
 /// < Alias for second component
 pub g : f32 ,
 /// < Alias for third component
 pub b : f32 ,
 /// < Alias for fourth component
 pub a : f32 , } # [ test ] fn bindgen_test_layout_vec4__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec4__bindgen_ty_3 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( vec4__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec4__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec4__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_3 ) ) . r as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_3 ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_3 ) ) . g as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_3 ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_3 ) ) . b as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_3 ) , "::" , stringify ! ( b ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_3 ) ) . a as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_3 ) , "::" , stringify ! ( a ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec4__bindgen_ty_4 {
 /// < Alias for first component
 pub red : f32 ,
 /// < Alias for second component
 pub green : f32 ,
 /// < Alias for third component
 pub blue : f32 ,
 /// < Alias for fourth component
 pub alpha : f32 , } # [ test ] fn bindgen_test_layout_vec4__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec4__bindgen_ty_4 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( vec4__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec4__bindgen_ty_4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec4__bindgen_ty_4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_4 ) ) . red as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_4 ) , "::" , stringify ! ( red ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_4 ) ) . green as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_4 ) , "::" , stringify ! ( green ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_4 ) ) . blue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_4 ) , "::" , stringify ! ( blue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4__bindgen_ty_4 ) ) . alpha as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( vec4__bindgen_ty_4 ) , "::" , stringify ! ( alpha ) ) ) ; } # [ test ] fn bindgen_test_layout_vec4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec4 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( vec4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec4 ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec4 ) , "::" , stringify ! ( data ) ) ) ; }
 /// Tuple of 3 floats
///
/// Each field can be addressed using several aliases:
/// - First component:  <b>x</b>, <b>r</b> or <b>red</b>
/// - Second component: <b>y</b>, <b>g</b> or <b>green</b>
/// - Third component:  <b>z</b>, <b>b</b> or <b>blue</b>
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union vec3 {
 /// < All compoments at once
 pub data : [ f32 ; 3usize ] , pub __bindgen_anon_1 : vec3__bindgen_ty_1 , pub __bindgen_anon_2 : vec3__bindgen_ty_2 , pub __bindgen_anon_3 : vec3__bindgen_ty_3 ,  } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec3__bindgen_ty_1 {
 /// < Alias for first component
 pub x : f32 ,
 /// < Alias fo second component
 pub y : f32 ,
 /// < Alias fo third component
 pub z : f32 , } # [ test ] fn bindgen_test_layout_vec3__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec3__bindgen_ty_1 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( vec3__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec3__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec3__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_1 ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_1 ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_1 ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_1 ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_1 ) ) . z as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_1 ) , "::" , stringify ! ( z ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec3__bindgen_ty_2 {
 /// < Alias for first component
 pub r : f32 ,
 /// < Alias fo second component
 pub g : f32 ,
 /// < Alias fo third component
 pub b : f32 , } # [ test ] fn bindgen_test_layout_vec3__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec3__bindgen_ty_2 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( vec3__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec3__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec3__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_2 ) ) . r as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_2 ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_2 ) ) . g as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_2 ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_2 ) ) . b as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_2 ) , "::" , stringify ! ( b ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec3__bindgen_ty_3 {
 /// < Alias for first component
 pub red : f32 ,
 /// < Alias fo second component
 pub green : f32 ,
 /// < Alias fo third component
 pub blue : f32 , } # [ test ] fn bindgen_test_layout_vec3__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec3__bindgen_ty_3 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( vec3__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec3__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec3__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_3 ) ) . red as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_3 ) , "::" , stringify ! ( red ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_3 ) ) . green as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_3 ) , "::" , stringify ! ( green ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3__bindgen_ty_3 ) ) . blue as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( vec3__bindgen_ty_3 ) , "::" , stringify ! ( blue ) ) ) ; } # [ test ] fn bindgen_test_layout_vec3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec3 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( vec3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec3 ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec3 ) , "::" , stringify ! ( data ) ) ) ; }
 /// Tuple of 2 floats
///
/// Each field can be addressed using several aliases:
/// - First component:  <b>x</b> or <b>s</b>
/// - Second component: <b>y</b> or <b>t</b>
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union vec2 {
 /// < All components at once
 pub data : [ f32 ; 2usize ] , pub __bindgen_anon_1 : vec2__bindgen_ty_1 , pub __bindgen_anon_2 : vec2__bindgen_ty_2 ,  } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec2__bindgen_ty_1 {
 /// < Alias for first component
 pub x : f32 ,
 /// < Alias for second component
 pub y : f32 , } # [ test ] fn bindgen_test_layout_vec2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( vec2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec2__bindgen_ty_1 ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec2__bindgen_ty_1 ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec2__bindgen_ty_1 ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec2__bindgen_ty_1 ) , "::" , stringify ! ( y ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct vec2__bindgen_ty_2 {
 /// < Alias for first component
 pub s : f32 ,
 /// < Alias for second component
 pub t : f32 , } # [ test ] fn bindgen_test_layout_vec2__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec2__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( vec2__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec2__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec2__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec2__bindgen_ty_2 ) ) . s as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec2__bindgen_ty_2 ) , "::" , stringify ! ( s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec2__bindgen_ty_2 ) ) . t as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( vec2__bindgen_ty_2 ) , "::" , stringify ! ( t ) ) ) ; } # [ test ] fn bindgen_test_layout_vec2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < vec2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( vec2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < vec2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( vec2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const vec2 ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( vec2 ) , "::" , stringify ! ( data ) ) ) ; }
 /// A texture atlas is used to pack several small regions into a single texture.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct texture_atlas_t {
 /// Allocated nodes
 pub nodes : * mut vector_t ,
 /// Width (in pixels) of the underlying texture
 pub width : usize ,
 /// Height (in pixels) of the underlying texture
 pub height : usize ,
 /// Depth (in bytes) of the underlying texture
 pub depth : usize ,
 /// Allocated surface size
 pub used : usize ,
 /// Texture identity (OpenGL)
 pub id : :: std :: os :: raw :: c_uint ,
 /// Atlas data
 pub data : * mut :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_texture_atlas_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < texture_atlas_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( texture_atlas_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < texture_atlas_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( texture_atlas_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . nodes as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( nodes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . width as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . height as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . depth as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( depth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . used as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( used ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . id as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_atlas_t ) ) . data as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( texture_atlas_t ) , "::" , stringify ! ( data ) ) ) ; } extern "C" {

 /// Creates a new empty texture atlas.
///
/// @param   width   width of the atlas
/// @param   height  height of the atlas
/// @param   depth   bit depth of the atlas
/// @return          a new empty texture atlas.
///

 pub fn texture_atlas_new ( width : usize , height : usize , depth : usize , ) -> * mut texture_atlas_t ;
} extern "C" {

 /// Deletes a texture atlas.
///
/// @param self a texture atlas structure
///

 pub fn texture_atlas_delete ( self_ : * mut texture_atlas_t , ) ;
} extern "C" {

 /// Allocate a new region in the atlas.
///
/// @param self   a texture atlas structure
/// @param width  width of the region to allocate
/// @param height height of the region to allocate
/// @return       Coordinates of the allocated region
///

 pub fn texture_atlas_get_region ( self_ : * mut texture_atlas_t , width : usize , height : usize , ) -> ivec4 ;
} extern "C" {

 /// Upload data to the specified atlas region.
///
/// @param self   a texture atlas structure
/// @param x      x coordinate the region
/// @param y      y coordinate the region
/// @param width  width of the region
/// @param height height of the region
/// @param data   data to be uploaded into the specified region
/// @param stride stride of the data
///

 pub fn texture_atlas_set_region ( self_ : * mut texture_atlas_t , x : usize , y : usize , width : usize , height : usize , data : * const :: std :: os :: raw :: c_uchar , stride : usize , ) ;
} extern "C" {

 /// Remove all allocated regions from the atlas.
///
/// @param self   a texture atlas structure

 pub fn texture_atlas_clear ( self_ : * mut texture_atlas_t , ) ;
} pub const rendermode_t_RENDER_NORMAL : rendermode_t = 0 ; pub const rendermode_t_RENDER_OUTLINE_EDGE : rendermode_t = 1 ; pub const rendermode_t_RENDER_OUTLINE_POSITIVE : rendermode_t = 2 ; pub const rendermode_t_RENDER_OUTLINE_NEGATIVE : rendermode_t = 3 ; pub const rendermode_t_RENDER_SIGNED_DISTANCE_FIELD : rendermode_t = 4 ; pub type rendermode_t = :: std :: os :: raw :: c_uint ;
 /// A structure that hold a kerning value relatively to a Unicode
/// codepoint.
///
/// This structure cannot be used alone since the (necessary) right
/// Unicode codepoint is implicitely held by the owner of this structure.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct kerning_t {
 /// Left Unicode codepoint in the kern pair in UTF-32 LE encoding.
 pub codepoint : u32 ,
 /// Kerning value (in fractional pixels).
 pub kerning : f32 , } # [ test ] fn bindgen_test_layout_kerning_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < kerning_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( kerning_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < kerning_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( kerning_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const kerning_t ) ) . codepoint as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( kerning_t ) , "::" , stringify ! ( codepoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const kerning_t ) ) . kerning as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( kerning_t ) , "::" , stringify ! ( kerning ) ) ) ; }
 /// A structure that describe a glyph.
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct texture_glyph_t {
 /// Unicode codepoint this glyph represents in UTF-32 LE encoding.
 pub codepoint : u32 ,
 /// Glyph's width in pixels.
 pub width : usize ,
 /// Glyph's height in pixels.
 pub height : usize ,
 /// Glyph's left bearing expressed in integer pixels.
 pub offset_x : :: std :: os :: raw :: c_int ,
 /// Glyphs's top bearing expressed in integer pixels.
    ///
    /// Remember that this is the distance from the baseline to the top-most
    /// glyph scanline, upwards y coordinates being positive.
 pub offset_y : :: std :: os :: raw :: c_int ,
 /// For horizontal text layouts, this is the horizontal distance (in
    /// fractional pixels) used to increment the pen position when the glyph is
    /// drawn as part of a string of text.
 pub advance_x : f32 ,
 /// For vertical text layouts, this is the vertical distance (in fractional
    /// pixels) used to increment the pen position when the glyph is drawn as
    /// part of a string of text.
 pub advance_y : f32 ,
 /// First normalized texture coordinate (x) of top-left corner
 pub s0 : f32 ,
 /// Second normalized texture coordinate (y) of top-left corner
 pub t0 : f32 ,
 /// First normalized texture coordinate (x) of bottom-right corner
 pub s1 : f32 ,
 /// Second normalized texture coordinate (y) of bottom-right corner
 pub t1 : f32 ,
 /// A vector of kerning pairs relative to this glyph.
 pub kerning : * mut vector_t ,
 /// Mode this glyph was rendered
 pub rendermode : rendermode_t ,
 /// Glyph outline thickness
 pub outline_thickness : f32 , } # [ test ] fn bindgen_test_layout_texture_glyph_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < texture_glyph_t > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( texture_glyph_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < texture_glyph_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( texture_glyph_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . codepoint as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( codepoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . width as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . height as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . offset_x as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( offset_x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . offset_y as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( offset_y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . advance_x as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( advance_x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . advance_y as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( advance_y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . s0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( s0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . t0 as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( t0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . s1 as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( s1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . t1 as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( t1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . kerning as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( kerning ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . rendermode as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( rendermode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_glyph_t ) ) . outline_thickness as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( texture_glyph_t ) , "::" , stringify ! ( outline_thickness ) ) ) ; }
 /// Texture font structure.
 # [ repr ( C ) ] # [ derive ( Debug, Copy , Clone ) ] pub struct texture_font_t {
 /// This field is simply used to compute a default line spacing (i.e., the
    /// baseline-to-baseline distance) when writing text with this font. Note
    /// that it usually is larger than the sum of the ascender and descender
    /// taken as absolute values. There is also no guarantee that no glyphs
    /// extend above or below subsequent baselines when using this distance.
 pub height : f32 ,

 /// Vector of glyphs contained in this font.
 pub glyphs : * mut vector_t ,

 /// Atlas structure to store glyphs data.
 pub atlas : * mut texture_atlas_t ,

 /// Font size
 pub size : f32 ,

 /// Whether to use autohint when rendering font
 pub hinting : :: std :: os :: raw :: c_int ,
 /// Mode the font is rendering its next glyph
 pub rendermode : rendermode_t ,
 /// Outline thickness
 pub outline_thickness : f32 ,
 /// Whether to use our own lcd filter.
 pub filtering : :: std :: os :: raw :: c_int ,
 /// LCD filter weights
 pub lcd_weights : [ :: std :: os :: raw :: c_uchar ; 5usize ] ,
 /// Whether to use kerning if available
 pub kerning : :: std :: os :: raw :: c_int ,
 /// This field is the distance that must be placed between two lines of
    /// text. The baseline-to-baseline distance should be computed as:
    /// ascender - descender + linegap
 pub linegap : f32 ,
 /// The ascender is the vertical distance from the horizontal baseline to
    /// the highest 'character' coordinate in a font face. Unfortunately, font
    /// formats define the ascender differently. For some, it represents the
    /// ascent of all capital latin characters (without accents), for others it
    /// is the ascent of the highest accented character, and finally, other
    /// formats define it as being equal to bbox.yMax.
 pub ascender : f32 ,
 /// The descender is the vertical distance from the horizontal baseline to
    /// the lowest 'character' coordinate in a font face. Unfortunately, font
    /// formats define the descender differently. For some, it represents the
    /// descent of all capital latin characters (without accents), for others it
    /// is the ascent of the lowest accented character, and finally, other
    /// formats define it as being equal to bbox.yMin. This field is negative
    /// for values below the baseline.
 pub descender : f32 ,
 /// The position of the underline line for this face. It is the center of
    /// the underlining stem. Only relevant for scalable formats.
 pub underline_position : f32 ,
 /// The thickness of the underline for this face. Only relevant for scalable
    /// formats.
 pub underline_thickness : f32 ,

 pub location : texture_font_t__bindgen_ty_1 ,

 pub memory : texture_font_t__bindgen_ty_2__bindgen_ty_1 ,
}

 pub const texture_font_t_TEXTURE_FONT_FILE : texture_font_t__bindgen_ty_1 = 0 ;
 pub const texture_font_t_TEXTURE_FONT_MEMORY : texture_font_t__bindgen_ty_1 = 1 ;
 pub type texture_font_t__bindgen_ty_1 = :: std :: os :: raw :: c_uint ;

 # [ repr ( C ) ]
 # [ derive ( Copy , Clone ) ]
 #[cfg(not(target_os = "emscripten"))]
 pub union texture_font_t__bindgen_ty_2 {
     /// Font filename, for when location == TEXTURE_FONT_FILE
     pub filename : * mut :: std :: os :: raw :: c_char ,
     pub memory : texture_font_t__bindgen_ty_2__bindgen_ty_1 ,

 }

 # [ repr ( C ) ]
 # [ derive ( Copy , Clone ) ]
 #[cfg(target_os = "emscripten")]
 pub union texture_font_t__bindgen_ty_2 {
     /// Font filename, for when location == TEXTURE_FONT_FILE
     pub filename : * mut :: std :: os :: raw :: c_char ,
     pub memory : texture_font_t__bindgen_ty_2__bindgen_ty_1 ,
 }

 /// Font memory address, for when location == TEXTURE_FONT_MEMORY
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ]
 pub struct texture_font_t__bindgen_ty_2__bindgen_ty_1 {
     pub base : * const :: std :: os :: raw :: c_void ,
     pub size : usize ,
 }

 # [ test ] fn bindgen_test_layout_texture_font_t__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < texture_font_t__bindgen_ty_2__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( texture_font_t__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < texture_font_t__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( texture_font_t__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t__bindgen_ty_2__bindgen_ty_1 ) ) . base as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t__bindgen_ty_2__bindgen_ty_1 ) ) . size as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; } # [ test ] fn bindgen_test_layout_texture_font_t__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < texture_font_t__bindgen_ty_2 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( texture_font_t__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < texture_font_t__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( texture_font_t__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t__bindgen_ty_2 ) ) . filename as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t__bindgen_ty_2 ) , "::" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t__bindgen_ty_2 ) ) . memory as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t__bindgen_ty_2 ) , "::" , stringify ! ( memory ) ) ) ; } # [ test ] fn bindgen_test_layout_texture_font_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < texture_font_t > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( texture_font_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < texture_font_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( texture_font_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . glyphs as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( glyphs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . atlas as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( atlas ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . location as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( location ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . size as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . hinting as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( hinting ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . rendermode as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( rendermode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . outline_thickness as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( outline_thickness ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . filtering as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( filtering ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . lcd_weights as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( lcd_weights ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . kerning as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( kerning ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . height as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . linegap as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( linegap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . ascender as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( ascender ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . descender as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( descender ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . underline_position as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( underline_position ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const texture_font_t ) ) . underline_thickness as * const _ as usize } , 92usize , concat ! ( "Alignment of field: " , stringify ! ( texture_font_t ) , "::" , stringify ! ( underline_thickness ) ) ) ; }


extern "C" {

 /// This function creates a new texture font from given filename and size.  The
/// texture atlas is used to store glyph on demand. Note the depth of the atlas
/// will determine if the font is rendered as alpha channel only (depth = 1) or
/// RGB (depth = 3) that correspond to subpixel rendering (if available on your
/// freetype implementation).
///
/// @param atlas     A texture atlas
/// @param pt_size   Size of font to be created (in points)
/// @param filename  A font filename
///
/// @return A new empty font (no glyph inside yet)
///

 pub fn texture_font_new_from_file ( atlas : * mut texture_atlas_t , pt_size : f32 , filename : * const :: std :: os :: raw :: c_char , ) -> * mut texture_font_t ;
}
extern "C" {

 /// This function creates a new texture font from a memory location and size.
/// The texture atlas is used to store glyph on demand. Note the depth of the
/// atlas will determine if the font is rendered as alpha channel only
/// (depth = 1) or RGB (depth = 3) that correspond to subpixel rendering (if
/// available on your freetype implementation).
///
/// @param atlas       A texture atlas
/// @param pt_size     Size of font to be created (in points)
/// @param memory_base Start of the font file in memory
/// @param memory_size Size of the font file memory region, in bytes
///
/// @return A new empty font (no glyph inside yet)
///

 pub fn texture_font_new_from_memory ( atlas : * mut texture_atlas_t , pt_size : f32 , memory_base : * const :: std :: os :: raw :: c_void , memory_size : usize , ) -> * mut texture_font_t ;
} extern "C" {

 /// Delete a texture font. Note that this does not delete the glyph from the
/// texture atlas.
///
/// @param self a valid texture font

 pub fn texture_font_delete ( self_ : * mut texture_font_t , ) ;
} extern "C" {

 /// Request a new glyph from the font. If it has not been created yet, it will
/// be.
///
/// @param self      A valid texture font
/// @param codepoint Character codepoint to be loaded in UTF-8 encoding.
///
/// @return A pointer on the new glyph or 0 if the texture atlas is not big
/// enough
///

 pub fn texture_font_get_glyph ( self_ : * mut texture_font_t , codepoint : * const :: std :: os :: raw :: c_char , ) -> * mut texture_glyph_t ;
} extern "C" {

 /// Request an already loaded glyph from the font.
///
/// @param self      A valid texture font
/// @param codepoint Character codepoint to be found in UTF-8 encoding.
///
/// @return A pointer on the glyph or 0 if the glyph is not loaded

 pub fn texture_font_find_glyph ( self_ : * mut texture_font_t , codepoint : * const :: std :: os :: raw :: c_char , ) -> * mut texture_glyph_t ;
} extern "C" {

 /// Request the loading of a given glyph.
///
/// @param self       A valid texture font
/// @param codepoints Character codepoint to be loaded in UTF-8 encoding.
///
/// @return One if the glyph could be loaded, zero if not.

 pub fn texture_font_load_glyph ( self_ : * mut texture_font_t , codepoint : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {

 /// Request the loading of several glyphs at once.
///
/// @param self       A valid texture font
/// @param codepoints Character codepoints to be loaded in UTF-8 encoding. May
/// contain duplicates.
///
/// @return Number of missed glyph if the texture is not big enough to hold
/// every glyphs.

 pub fn texture_font_load_glyphs ( self_ : * mut texture_font_t , codepoints : * const :: std :: os :: raw :: c_char , ) -> usize ;
} extern "C" {
 pub fn texture_font_enlarge_atlas ( self_ : * mut texture_font_t , width_new : usize , height_new : usize , ) ;
} extern "C" {

 /// Get the kerning between two horizontal glyphs.
///
/// @param self      A valid texture glyph
/// @param codepoint Character codepoint of the peceding character in UTF-8 encoding.
///
/// @return x kerning value

 pub fn texture_glyph_get_kerning ( self_ : * const texture_glyph_t , codepoint : * const :: std :: os :: raw :: c_char , ) -> f32 ;
} extern "C" {

 /// Creates a new empty glyph
///
/// @return a new empty glyph (not valid)

 pub fn texture_glyph_new ( ) -> * mut texture_glyph_t ;
}
